You are helping me implement a graph-coloring-like interference model using Extropic’s `thrml` library, using categorical variables and a custom discrete EBM factor (a generalized Potts model).

IMPORTANT:
- Do NOT guess THRML class names or signatures.
- Look them up in the official THRML docs and GitHub repo:
  - https://docs.thrml.ai
  - https://github.com/extropic-ai/thrml

Your job is to produce real, runnable Python code organized into a few files.  
No command line interface.  
Instead, write an example program where parameters are set in variables and a function is called that runs the sampler.

All code should be ASCII only (no fancy quotes).

================================================================
HIGH-LEVEL GOAL
================================================================

We want to encode TV-station/channel interference constraints as a discrete energy-based model:

- Stations:
  - Each station has an ID (like 87, 125, 126, 131, etc.).
  - We will map them to internal indices 0 .. N-1.

- Channels:
  - Channels are integers (like 2, 3, 4, ..., 51).
  - For a given station, only some channels are allowed.
  - We will treat the channels as the K possible states for each station’s categorical variable:
    - colors[i] in {0, 1, ..., K-1}, where each integer corresponds to a physical channel number.

- Constraints:
  - Domain constraints: which channels each station is allowed to use.
  - Interference constraints: which pairs of station-channel assignments are forbidden:
    - CO (co-channel) interference
    - ADJ+1 (adjacent plus one) interference
    - ADJ-1 (adjacent minus one) interference

We want to build:

1) Parsing of CSV files that describe the domain and interference constraints.
2) Pure JAX helper functions for energy and conflict counting.
3) A custom THRML factor (PottsGraphFactor) that encodes all pairwise station/channel constraints as a K x K penalty table per station pair (edge).
4) A THRML energy-based model with:
   - One categorical node per station.
   - One PottsGraphFactor (or equivalent) that handles all pairwise constraints.
5) A block Gibbs sampler using THRML’s discrete EBM utilities.
6) An example program where we set parameters as variables and call a function that runs the sampler and prints energy/conflicts.

================================================================
FILE FORMATS
================================================================

You must implement parsing for the following CSV files.

---------------------------------------------------------------
1. Domain.csv (station -> allowed channels)
---------------------------------------------------------------

Example lines:

DOMAIN,87,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51
DOMAIN,125,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51
DOMAIN,126,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51
DOMAIN,131,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51

Format:
- Column 1: string "DOMAIN".
- Column 2: station ID (integer).
- Columns 3+: allowed channels for that station (integers).

Semantics:
- For each station S, the row lists ALL channels that S is allowed to use.
- If a station does not appear in Domain.csv, you can either:
  - treat it as having an empty domain (disallowed), or
  - ignore that station.
  For now, assume all stations we care about appear in Domain.csv.

Internal representation:
- Build a list or array of unique station IDs.
- Map station ID -> internal index i in [0, N-1].
- Determine the global set of channel numbers seen, and sort them. For example:
  - channels_sorted = sorted( set of all channels that appear in any DOMAIN row ).
  - Let K = len(channels_sorted).
- Build:
  - station_ids: numpy array of shape (N,) with the station IDs (for reference).
  - channel_values: numpy array of shape (K,) listing the physical channel numbers (e.g. [2,3,4,...,51]).
  - domain_mask: boolean array of shape (N, K) where:
    - domain_mask[i, k] = True if station i is allowed to use channel channel_values[k].
    - domain_mask[i, k] = False otherwise.

Later, when we talk about the categorical color "state" a in [0..K-1] for station i, that maps to the physical channel channel_values[a]. The domain_mask will be enforced in the energy function (disallowed states get a large penalty or are masked).

---------------------------------------------------------------
2. Interference_Paired.csv (pairwise interference constraints)
---------------------------------------------------------------

Example lines:

CO,3,3,63331,334,2424,10205,10228,10242,19191,20871,22644,25048,25452,33778,33875,34440,34577,35280,35500,35663,35703,35855,43095,48360,51189,51493,51499,52891,52953,56550,57945,58912,59139,60307,64987,65526
CO,3,3,63557,9425,9614,10203,11123,12497,13456,18894,22093,27290,29715,35575,39736,47902,48608,51349,51988,52527,53113,59443,60536,61084,63154,63840,64971,66358,67602,67971,70865,71085,71580,73230,83929
CO,3,3,63768,10179,10195,10498,11683,14302,33819,35042,35870,41237,66807,67089,69677,74100
CO,3,3,63840,4366,9425,9614,10203,11123,12497,13456,19183,22093,27290,29547,29715,30129,35575,39736,47902,48608,51349,51988,52527,53113,59443,60165,60536,61084,61504,62388,63154,63557,64971,66358,67971,70649,70865,71085,71580,72053,73230,83929
CO,3,3,63845

There are also adjacent-channel lines like:

ADJ-1,4,3,87,50194,86532
ADJ+1,3,4,87,50194,86532

Format:
- Column 1: constraint type. One of:
  - "CO"    for co-channel.
  - "ADJ+1" for adjacent plus one.
  - "ADJ-1" for adjacent minus one.
- Column 2: channel for the first station (integer, call it c1).
- Column 3: channel for the second station (integer, call it c2).
- Column 4: first station ID (integer, call it s1).
- Columns 5+: list of second station IDs that are not permitted in combination with s1 for the given channel pair (c1, c2).

Semantics:
- A row like:
    TYPE, c1, c2, s1, s2_1, s2_2, ..., s2_k
  means:
  "Assignments where station s1 is on channel c1 and station s2_j is on channel c2 (for any j) are forbidden for this constraint type."

- For "CO" lines, c1 == c2 (same channel). This means: do not allow both stations to use the same channel c1 at the same time (co-channel interference).
- For "ADJ+1" lines, c2 = c1 + 1. This means: do not allow station s1 on channel c1 and station s2 on channel c1 + 1.
- For "ADJ-1" lines, c2 = c1 - 1. Similarly, do not allow s1 on c1 and s2 on c1 - 1.

Internal representation:
- Use the same station ID -> index mapping and channel_values mapping as for Domain.csv.
- For each row:
  - Map station IDs (s1 and s2_j) to indices i and j.
  - Map channels c1 and c2 to indices a and b in [0..K-1] by looking them up in channel_values.
- For each pair (i, j) that appears, we want to store a set of disallowed (a, b) channel-state pairs.
- A convenient structure:
  - edges: list of unique unordered station pairs (i, j) (i != j).
  - For each edge (i, j), build a K x K penalty matrix W_ij:
    - W_ij[a, b] = penalty if station i uses channel a and station j uses channel b.
    - For any disallowed pair (a, b) from CO, ADJ+1, ADJ-1, set W_ij[a, b] = edge_penalty.
    - All other entries can be 0.
  - Depending on whether the constraints are symmetric or directional in the data, you may want to:
    - also set W_ij[b, a], or
    - treat them as directed. For now, you can assume they should be symmetric and mark with a comment:
      # TODO: confirm whether interference constraints are symmetric between stations.
- Note: many edges will share the same general pattern (e.g., all CO constraints at channel 3). For simplicity, you can build a separate W_ij per edge; later, we can optimize.

================================================================
SOFTWARE STRUCTURE
================================================================

We will pretend we are creating a small package with these files:

- graph.py
- potts_factor.py
- model.py
- tools/example_run.py

You should output the contents of these files in one answer, clearly labeled:

# graph.py
...code...

# potts_factor.py
...code...

etc.

Below are detailed requirements per file.

================================================================
STEP 1: graph.py
================================================================

This file handles:

- Parsing Domain.csv and Interference_Paired.csv.
- Building station and channel mappings.
- Producing domain masks and constraint structures.
- Pure JAX helper functions for energy, conflicts, and random initialization.

Implement:

1) Station and domain parsing:

- A function:

    def load_domain_csv(path: str):
        """
        Parse Domain.csv.
        Returns:
            station_ids: numpy array of shape (N,) with sorted unique station IDs.
            channel_values: numpy array of shape (K,) with sorted unique channel numbers.
            domain_mask: boolean numpy array of shape (N, K) such that:
                domain_mask[i, k] = True if station_ids[i] is allowed to use channel_values[k].
        """

Implement steps:
- Read CSV lines.
- For each "DOMAIN" row:
  - Collect station ID and allowed channels.
- Build sorted unique station_ids.
- Build sorted unique channel_values (set of all channels seen).
- Build station_id_to_index and channel_value_to_index dicts.
- Build domain_mask with False by default, set True for allowed channel assignments.

2) Interference parsing:

- A function:

    def load_interference_csv(path: str, station_ids, channel_values):
        """
        Parse Interference_Paired.csv.
        station_ids: numpy array from load_domain_csv
        channel_values: numpy array from load_domain_csv

        Returns:
            edges: numpy array of shape (E, 2) with station indices (0..N-1).
            edge_weight_tensors: numpy array or list of shape (E, K, K) where:
                edge_weight_tensors[e][a, b] = penalty for station at edges[e,0] on channel a
                                               and station at edges[e,1] on channel b.
        """

Requirements:
- Build a mapping from station IDs to indices (reuse station_ids).
- Build a mapping from channel numbers to indices (reuse channel_values).
- Use a dictionary keyed by an unordered station pair (i, j) (for i != j) to accumulate disallowed (a, b) pairs:
  - key can be tuple(sorted((i, j))).
  - value is a K x K numpy array of penalties, initialized to zeros.
- For each row in Interference_Paired.csv:
  - Parse TYPE, c1, c2, s1, s2_1, s2_2, ...
  - Map s1 to index i, each s2_k to index j.
  - Map c1 to a, c2 to b.
  - Get the pair key = (min(i, j), max(i, j)).
  - In the corresponding K x K matrix W:
    - set W[a, b] = edge_penalty_default, where edge_penalty_default is some constant penalty (e.g., 1.0 for now).
    - Optionally also set W[b, a] = edge_penalty_default for symmetry.
    - Mark with:
      # TODO: confirm symmetry for interference constraints.
- After processing all rows, convert this dictionary into:
  - edges: list of (i, j)
  - edge_weight_tensors: list of W_ij matrices.
  Then convert to numpy arrays.

You can choose to pass edge_penalty_default into this function or hardcode a default and let the THRML model scale it later. For now, you can return W_ij with entries 0 or 1 and multiply by the edge penalty in the PottsGraphFactor.

3) Pure JAX helpers:

Using JAX (no THRML here), implement:

    import jax
    import jax.numpy as jnp

    def potts_energy(colors: jnp.ndarray,
                     edges: jnp.ndarray,
                     edge_weights: jnp.ndarray,
                     edge_penalty: float) -> jnp.ndarray:
        """
        colors: shape (N,), int32 in [0, K)
        edges: shape (E, 2), int32 station indices
        edge_weights: shape (E, K, K), base penalty tables (0 or 1)
        edge_penalty: float penalty scale

        Returns scalar energy:
            E = edge_penalty * sum_e edge_weights[e, colors[u], colors[v]]
        """

    def conflict_count(colors: jnp.ndarray,
                       edges: jnp.ndarray,
                       edge_weights: jnp.ndarray) -> jnp.ndarray:
        """
        Count how many station pairs (edges) violate any constraint:
        i.e. sum over e indicator[ edge_weights[e, colors[u], colors[v]] > 0 ].
        """

    def random_initial_colors(key: jax.Array, N: int, K: int, domain_mask: jnp.ndarray) -> jnp.ndarray:
        """
        Randomly initialize colors with respect to domain_mask:
            - For each station i, pick a color a such that domain_mask[i, a] is True.
        Return colors: shape (N,), int32.
        If a station has no allowed colors, you may raise an error.
        """

4) Optionally, a helper:

    def indices_from_station_ids(station_ids: np.ndarray):
        """
        Return a dict mapping station ID -> index.
        """

================================================================
STEP 2: potts_factor.py
================================================================

This file defines a custom THRML discrete EBM factor that encodes all pairwise station/channel penalties.

1) Imports:

- Import the correct base class for discrete EBM factors from THRML. For example (you must confirm):
  
    from thrml.models.discrete_ebm import DiscreteEBMFactor

- Import any utilities needed from THRML to deal with categorical nodes and interaction groups.
- Import jax.numpy as jnp.

2) Class design:

Create:

    class PottsGraphFactor(DiscreteEBMFactor):
        def __init__(self, nodes, edges, edge_weights, edge_penalty: float, **kwargs):
            """
            nodes: list of categorical nodes (one per station)
            edges: JAX array of shape (E, 2) with station indices
            edge_weights: JAX array of shape (E, K, K) with base penalties (0 or 1)
            edge_penalty: float penalty scale
            """

Responsibilities:
- Store nodes, edges, and edge_weights.
- Build whatever node_groups and weights structure `DiscreteEBMFactor` needs, following the pattern of `CategoricalEBMFactor`.

Key idea:
- For each edge e = (i, j), we have a K x K matrix W_e (from edge_weights).
- The energy contribution from this factor should be:

    sum_e edge_penalty * W_e[ colors[i], colors[j] ]

so that the THRML global energy matches potts_energy.

Implementation steps (based on THRML’s discrete EBM pattern):
- Examine the THRML docs and source for:
  - how `CategoricalEBMFactor` initializes `DiscreteEBMFactor`.
  - how it sets `node_groups` (which nodes are connected by each factor).
  - how it arranges `weights` (shape, axes).
  - how `to_interaction_groups` is implemented, if necessary.

- Follow that pattern but feed it:
  - the list of node pairs corresponding to edges.
  - the tensor of edge_weights (scaled by the edge penalty if needed).

If `DiscreteEBMFactor` provides the energy computation, you may not need to write an `energy` method. If you do need to write one, implement it using `edges` and `edge_weights` exactly like potts_energy does.

Where you are unsure, add:

    # TODO: adjust to actual thrml DiscreteEBMFactor API

================================================================
STEP 3: model.py
================================================================

This file will:

- Create THRML categorical nodes (one per station).
- Create a PottsGraphFactor with edges and edge_weights.
- Build a THRML sampling program (block Gibbs) for the discrete EBM.

1) Imports:

- jax and jax.numpy
- CategoricalNode from THRML (confirm module path, e.g. `thrml.pgm.CategoricalNode`).
- Discrete EBM and sampling components from THRML:
  - For example (you must verify):
    - CategoricalGibbsConditional
    - FactorSamplingProgram or BlockSamplingProgram
    - Block, BlockGibbsSpec, etc.
- PottsGraphFactor from potts_factor.py.

2) Model construction function:

Implement:

    def build_potts_coloring_model(station_ids,
                                   channel_values,
                                   edges_np,
                                   edge_weights_np,
                                   edge_penalty: float):
        """
        station_ids: numpy array of shape (N,)
        channel_values: numpy array of shape (K,)
        edges_np: numpy array of shape (E, 2) with station indices
        edge_weights_np: numpy array of shape (E, K, K)
        edge_penalty: float penalty scale

        Returns:
            sampling_program: a THRML sampling program object
            nodes: list of categorical nodes
        """

Steps inside:
- Convert edges_np and edge_weights_np to JAX arrays.
- Let N = number of stations, K = number of channels.
- Create N categorical nodes, one per station:

    nodes = [CategoricalNode(num_states=K, name=f"station_{station_ids[i]}") for i in range(N)]

  (Confirm the real parameter name for the number of states, e.g. num_states or num_categories.)

- Create a PottsGraphFactor:

    potts_factor = PottsGraphFactor(nodes=nodes,
                                    edges=edges_jax,
                                    edge_weights=edge_weights_jax,
                                    edge_penalty=edge_penalty)

- Build a THRML sampling program:
  - Inspect the "Getting Started" discrete EBM example in the THRML docs.
  - See how it uses:
    - FactorSamplingProgram (or similar) with:
      - factors = [potts_factor]
      - a BlockGibbsSpec describing the free block of categorical nodes
      - CategoricalGibbsConditional as the sampler for that block
    - and returns a BlockSamplingProgram or something similar.

- Your function should return an object that the caller can use to advance the state, for example:

    state = sampling_program.init_state(...)
    state = sampling_program.step(state, rng_key)

or a wrapper that runs sample_states.

Where the exact pattern is unclear, copy as closely as possible from the discrete EBM example in the docs and add:

    # TODO: check thrml docs for exact FactorSamplingProgram usage

================================================================
STEP 4: tools/example_run.py
================================================================

This file should provide a simple, self-contained example run with no command line parsing.

1) Imports:

- numpy
- jax, jax.numpy
- From graph.py:
  - load_domain_csv
  - load_interference_csv
  - potts_energy
  - conflict_count
  - random_initial_colors
- From model.py:
  - build_potts_coloring_model

2) Implement:

    def run_example():
        """
        Example run of the Potts-based interference model.
        """

Inside run_example:

- Hardcode file paths or use small_test_graph style data.

Example structure:

    # Example inputs (replace with real paths as needed)
    domain_csv_path = "Domain.csv"
    interference_csv_path = "Interference_Paired.csv"

    # Load domain and station/channel sets
    station_ids, channel_values, domain_mask_np = load_domain_csv(domain_csv_path)

    # Load interference constraints and build edges and edge weights
    edges_np, edge_weights_np = load_interference_csv(interference_csv_path,
                                                      station_ids,
                                                      channel_values)

    # Convert domain mask to JAX
    domain_mask = jax.device_put(domain_mask_np)

    N = station_ids.shape[0]
    K = channel_values.shape[0]
    E = edges_np.shape[0]

    # Set parameters
    edge_penalty = 1.0
    steps = 1000
    seed = 0

    # Build THRML model and sampling program
    sampling_program, nodes = build_potts_coloring_model(station_ids,
                                                         channel_values,
                                                         edges_np,
                                                         edge_weights_np,
                                                         edge_penalty)

    # Initialize colors
    key = jax.random.PRNGKey(seed)
    colors = random_initial_colors(key, N, K, domain_mask)

    # Track best seen configuration
    edges_jax = jax.device_put(edges_np)
    edge_weights_jax = jax.device_put(edge_weights_np)

    best_colors = colors
    best_energy = potts_energy(colors, edges_jax, edge_weights_jax, edge_penalty)
    print("init energy:", best_energy,
          "conflicts:", conflict_count(colors, edges_jax, edge_weights_jax))

    # If sampling_program requires a state object different from 'colors',
    # you may need to wrap/unwrap; add appropriate adapter code and comments.

    for t in range(steps):
        key, subkey = jax.random.split(key)
        # Advance the sampler by one step.
        # Replace this with the real call, eg:
        # colors = sampling_program.step(colors, subkey)
        # or something similar, depending on THRML's API.
        # TODO: adapt this to actual thrml sampling API.

        if t % 100 == 0:
            E = potts_energy(colors, edges_jax, edge_weights_jax, edge_penalty)
            C = conflict_count(colors, edges_jax, edge_weights_jax)
            if E < best_energy:
                best_energy = E
                best_colors = colors
            print("step", t, "energy:", E, "conflicts:", C)

    print("best energy:", best_energy,
          "best conflicts:", conflict_count(best_colors, edges_jax, edge_weights_jax))

3) Add:

    if __name__ == "__main__":
        run_example()

================================================================
STEP 5: WHAT I EXPECT FROM YOU
================================================================

1) You must look up the real THRML APIs in:
   - https://docs.thrml.ai
   - https://github.com/extropic-ai/thrml

2) You must produce complete Python code for:
   - graph.py
   - potts_factor.py
   - model.py
   - tools/example_run.py

3) You must base PottsGraphFactor on the real discrete EBM base class (from thrml.models.discrete_ebm), following the pattern of CategoricalEBMFactor or equivalent.

4) You should not silently invent APIs. When you are not sure, make a best guess and mark the line with a comment:

   # TODO: adjust to actual thrml API

5) The final answer must contain the four files in sequence, clearly labeled, so I can copy and paste them.

That is the full specification.
